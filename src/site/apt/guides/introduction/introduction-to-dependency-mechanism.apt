 ------
 Introduction to the Dependency Mechanism
 ------
 Brett Porter
 Trygve Laugstol
 ------
 12 October 2005
 ------

Introduction to the Dependency Mechanism

  Dependency management is one of the features of Maven that is best known to users and is one of the areas where Maven
  excels. There is not much difficulty in managing dependencies for a single a project, but when you start getting into
  dealing with multi-module projects and applications that consist of tens or hundreds of modules this is where Maven can
  help you a great deal in maintaining a high degree of control and stability.

  Learn more about:

 * Transitive Dependencies

 * Dependency Scope

 * Dependency Management

 []

* Transitive Dependencies

 Transitive dependencies are a new feature in Maven 2.0. This allows you to avoid needing to discover and
 specify the libraries that your own dependencies require, and including them automatically.

 This feature is facilitated by reading the project files of your dependencies from the remote repositories
 specified. In general, all dependencies of those projects are used in your project, as are any that the
 project inherits from its parents, or from its dependencies, and so on.

 There is no limit to the number of levels that dependencies can be gathered from, and will only cause a
 problem if a cyclic dependency is discovered.

 With transitive dependencies, the graph of included libraries can quickly grow quite large. For this reason,
 there are some additional features that will limit which dependencies are included:

 * <Dependency mediation>
   - this determines what version of a dependency will be used when multiple
     versions of an artifact are encountered. Currently, Maven 2.0 only supports using the "nearest definition" which means
     that it will use the version of the closest dependency to your project in the tree of dependencies.
     You can always guarantee a version by declaring it explicitly in your project's POM.
     Note that if two dependency versions are at the same depth in the dependency tree it's not defined which one will win.

     * "nearest definition" means that the version used will be the closest one to your project in the tree of dependencies,
        eg. if dependencies for A, B, and C are defined as A -> B -> C -> D 2.0 and A -> E -> D 1.0,
        then D 1.0 will be used when building A because the path from A to D through E is shorter.
        You could explicitly add a dependency to D 2.0 in A to force the use of D 2.0

 * <Dependency management>
   - this allows project authors to directly specify the versions of artifiacts to be used when they are encountered
     in transitive dependencies or in dependencies where no version has been specified. In the example in
     the preceding section a dependency was directly added to A even though it is not directly used by A. Instead,
     A can include D as a dependency in its dependencyManagement section and directly control which version of
     D is used when, or if, it is ever referenced.

 * <Dependency scope>
   - this allows you to only include dependencies appropriate for the current stage
     of the build. This is described in more detail below.

 []

* Dependency Scope

 Dependency scope is used to limit the transitivity of a depedency, and also to affect the classpath used for
 various build tasks.

 There are 5 scopes available:

 * <<compile>>
   - this is the default scope, used if none is specified. Compile dependencies are available
     in all classpaths.

 * <<provided>>
   - this is much like compile, but indicates you expect the JDK or a container to provide it.
     It is only available on the compilation classpath, and is not transitive.

 * <<runtime>>
   - this scope indicates that the dependency is not required for compilation, but is for
     execution. It is in the runtime and test classpaths, but not the compile classpath.

 * <<test>>
   - this scope indicates that the dependency is not required for normal use of the application, and
     is only available for the test compilation and execution phases.

 * <<system>>
   - this scope is similar to provided except that you have to provide the JAR
     which contains it explicitly. The artifact is always available and is not
     looked up in a repository.

 []

 Each of the scopes affects transitive dependencies in different ways, as is demonstrated in the table below.
 If a dependency is set to the scope in the left column, dependencies with the scope across the top row will
 result in a dependency in the main project with the scope listed at the intersection. If no scope is listed,
 it means the dependency will be omitted.

*----------+------------+----------+----------+------+
|          | compile    | provided | runtime  | test
*----------+------------+----------+----------+------+
| compile  | compile(*) |    -     | runtime  |  -
*----------+------------+----------+----------+------+
| provided | provided   | provided | provided |  -
*----------+------------+----------+----------+------+
| runtime  | runtime    |    -     | runtime  |  _
*----------+------------+----------+----------+------+
| test     | test       |    -     | test     |  -
*----------+------------+----------+----------+------+

 <<(*) Note:>>
 it is intended that this should be runtime instead, so that all compile dependencies must
 be explicitly listed - however, there is the case where the library you depend on extends a class from another
 library, forcing you to have available at compile time. For this reason, compile time dependencies remain
 as compile scope even when they are transitive.

* Dependency Management

 The dependency management section is a mechanism for centralizing dependency information. When you have
 a set of projects that inherits a common parent it's possible to put all information about the dependency
 in the common POM and have simpler references to the artifacts in the child POMs. The mechanism is best
 illustrated through some examples. Given these two POMs which extend the same parent:

 Project A:

+----+

<project>
  ...
  <dependencies>
    <dependency>
      <groupId>group-a</groupId>
      <artifactId>artifact-a</artifactId>
      <version>1.0</version>
      <exclusions>
        <exclusion>
          <groupId>group-c</groupId>
          <artifactId>excluded-artifact</artifactId>
        </exclusion>
      </exclusions>
    </dependency>
    <dependency>
      <groupId>group-a</groupId>
      <artifactId>artifact-b</artifactId>
      <version>1.0</version>
      <type>bar</type>
      <scope>runtime</scope>
    </dependency>
  </dependencies>
</project>

+----+

 Project B:

+----+

<project>
  ...
  <dependencies>
    <dependency>
      <groupId>group-c</groupId>
      <artifactId>artifact-b</artifactId>
      <version>1.0</version>
      <type>war</type>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>group-a</groupId>
      <artifactId>artifact-b</artifactId>
      <version>1.0</version>
      <type>bar</type>
      <scope>runtime</scope>
    </dependency>
  </dependencies>
</project>

+----+

 These two example POMs share a common dependency and each has one non-trivial dependency. This information
 can be put in the parent POM like this:

+----+

<project>
  ...
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>group-a</groupId>
        <artifactId>artifact-a</artifactId>
        <version>1.0</version>

        <exclusions>
          <exclusion>
            <groupId>group-c</groupId>
            <artifactId>excluded-artifact</artifactId>
          </exclusion>
        </exclusions>

      </dependency>

      <dependency>
        <groupId>group-c</groupId>
        <artifactId>artifact-b</artifactId>
        <version>1.0</version>
        <type>war</type>
        <scope>runtime</scope>
      </dependency>

      <dependency>
        <groupId>group-a</groupId>
        <artifactId>artifact-b</artifactId>
        <version>1.0</version>
        <type>bar</type>
        <scope>runtime</scope>
      </dependency>
    </dependencies>
  </dependencyManagement>
</project>

+----+

 And then the two child poms would become much simpler:

+----+

<project>
  ...
  <dependencies>
    <dependency>
      <groupId>group-a</groupId>
      <artifactId>artifact-a</artifactId>
    </dependency>

    <dependency>
      <groupId>group-a</groupId>
      <artifactId>artifact-b</artifactId>
      <!-- This is not a jar dependency, so we must specify type. -->
      <type>bar</type>
    </dependency>
  </dependencies>
</project>

+----+

+----+

<project>
  ...
  <dependencies>
    <dependency>
      <groupId>group-c</groupId>
      <artifactId>artifact-b</artifactId>
      <!-- This is not a jar dependency, so we must specify type. -->
      <type>war</type>
    </dependency>

    <dependency>
      <groupId>group-a</groupId>
      <artifactId>artifact-b</artifactId>
      <!-- This is not a jar dependency, so we must specify type. -->
      <type>bar</type>
    </dependency>
  </dependencies>
</project>

+----+

 <<NOTE:>> In two of these dependency references, we had to specify the \<type/\>
 element. This is because the minimal set of information for matching a dependency
 reference against a dependencyManagement section is actually 
 <<\{groupId, artifactId, type, classifier\}>>. In many cases, these dependencies 
 will refer to jar artifacts with no classifier. This allows us to shorthand the 
 identity set to <<\{groupId, artifactId\}>>, since the default for the type field 
 is <<<jar>>>, and the default classifier is null.

 A second, and very important use of the dependency management section is to control the versions
 of artifacts used in transitive dependencies. As an example consider these projects:

 Project A:

+----+

<project>
 <modelVersion>4.0.0</modelVersion>
 <groupId>maven</groupId>
 <artifactId>A</artifactId>
 <packaging>pom</packaging>
 <name>A</name>
 <version>1.0</version>
 <dependencyManagement>
   <dependencies>
     <dependency>
       <groupId>test</groupId>
       <artifactId>a</artifactId>
       <version>1.2</version>
     </dependency>
     <dependency>
       <groupId>test</groupId>
       <artifactId>b</artifactId>
       <version>1.0</version>
       <scope>compile</scope>
     </dependency>
     <dependency>
       <groupId>test</groupId>
       <artifactId>c</artifactId>
       <version>1.0</version>
       <scope>compile</scope>
     </dependency>
     <dependency>
       <groupId>test</groupId>
       <artifactId>d</artifactId>
       <version>1.2</version>
     </dependency>
   </dependencies>
 </dependencyManagement>
</project>

+----+

 Project B:

+----+

<project>
  <parent>
    <artifactId>A</artifactId>
    <groupId>maven</groupId>
    <version>1.0</version>
  </parent>
  <modelVersion>4.0.0</modelVersion>
  <groupId>maven</groupId>
  <artifactId>B</artifactId>
  <packaging>pom</packaging>
  <name>B</name>
  <version>1.0</version>
  <dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>test</groupId>
        <artifactId>d</artifactId>
        <version>1.0</version>
      </dependency>
    </dependencies>
  </dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>maven-test</groupId>
      <artifactId>a</artifactId>
      <version>1.0</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>maven-test</groupId>
      <artifactId>c</artifactId>
      <scope>runtime</scope>
    </dependency>
  </dependencies>
</project>

+----+

 When maven is run on project B version 1.0 of artifacts a, b, c, and d will be used regardless of
 the version specified in their pom.

 * a and c both are declared as dependencies of the project so  version 1.0 is used due to
 dependency mediation. Both will also have runtime scope since it is directly specified.

 * b is defined in B's parent's dependency managemnet section and since dependency management
 takes precedence over dependency mediation for transitive dependencies, version 1.0 will be
 selected should it be referenced in a or c's pom. b will also have compile scope.
 
 * Finally, since d is specified in B's dependency management section, should d be a dependency
 (or transitive dependency) of a or c, version 1.0 will be chosen - again  because dependency
 management takes precedence over dependency mediation and also because the current pom's
 declaration takes precedence over its parent's declaration.
 
 []

 The reference information about the dependency management tags is available from the
 {{{../../ref/current/maven-model/maven.html#class_DependencyManagement}project descriptor reference}}.                 


* System Dependencies

 Dependencies with the scope <system> are always available and are not looked
 up in repository. They are usually used to tell Maven about dependencies which
 are provided by the JDK or the VM. Thus, system dependencies are especially
 useful for resolving dependencies on artifacts which are now provided by the
 JDK, but where available as separate downloads earlier. Typical example are
 the JDBC standard extensions or the Java Authentication and Authorization
 Service (JAAS).

 A simple example would be:

+----+

<project>
  ...
  <dependencies>
    <dependency>
      <groupId>javax.sql</groupId>
      <artifactId>jdbc-stdext</artifactId>
      <version>2.0</version>
      <scope>system</scope>
      <systemPath>${java.home}/lib/rt.jar</systemPath>
    </dependency>
  </dependencies>
  ...
</project>

+----+

 If your artifact is provided by the JDK's <<<tools.jar>>> the system path
 would be defined as follows:

+----+
<project>
  ...
  <dependencies>
    <dependency>
      <groupId>sun.jdk</groupId>
      <artifactId>tools</artifactId>
      <version>1.5.0</version>
      <scope>system</scope>
      <systemPath>${java.home}/../lib/tools.jar</systemPath>
    </dependency>
  </dependencies>
  ...
</project>
+----+

