 ------
 Guide to Configuring Plug-ins
 ------
 Jason van Zyl
 Vincent Siveton
 ------
 November 2006
 ------

~~ Licensed to the Apache Software Foundation (ASF) under one
~~ or more contributor license agreements.  See the NOTICE file
~~ distributed with this work for additional information
~~ regarding copyright ownership.  The ASF licenses this file
~~ to you under the Apache License, Version 2.0 (the
~~ "License"); you may not use this file except in compliance
~~ with the License.  You may obtain a copy of the License at
~~
~~   http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing,
~~ software distributed under the License is distributed on an
~~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
~~ KIND, either express or implied.  See the License for the
~~ specific language governing permissions and limitations
~~ under the License.

~~ NOTE: For help with the syntax of this file, see:
~~ http://maven.apache.org/doxia/references/apt-format.html

Guide to Configuring Plug-ins

  [[1]] {{{Mapping_Complex_Objects}Mapping Complex Objects}}

  [[2]] {{{Mapping_Collections}Mapping Collections}}

    [[1]] {{{Mapping_Lists}Mapping Lists}}

    [[2]] {{{Mapping_Maps}Mapping Maps}}

    [[3]] {{{Mapping_Properties}Mapping Properties}}

  [[3]] {{{Using_Setters}Using Setters}}

  [[4]] {{{Using_the_executions_Tag}Using the <<<\<executions\>>>> Tag}}

 In Maven plug-ins are configured by specifying a <<<\<configuration\>>>> element where the child elements of the
 <<<\<configuration\>>>> element are mapped to fields, or setters, inside your Mojo (remember that a plug-in consists of
 one or more Mojos where a Mojo maps to a goal). Say, for example, we had a Mojo that performed a query against
 a particular URL, with a specified timeout and list of options. The Mojo might look like the following:

+----+

/**
 * @goal query
 */
public class MyQueryMojo
    extends AbstractMojo
{
    /**
     * @parameter expression="${query.url}"
     */
    private String url;

    /**
     * @parameter default-value="60"
     */
    private int timeout;

    /**
     * @parameter
     */
    private String[] options;

    public void execute()
        throws MojoExecutionException
    {
        ...
    }
}

+----+

 To configure the Mojo from your POM with the desired URL, timeout and options you might have something like
 the following:

+----+

<project>
  ...
  <build>
    <plugins>
      <plugin>
        <artifactId>maven-myquery-plugin</artifactId>
        <version>1.0</version>
        <configuration>
          <url>http://www.foobar.com/query</url>
          <timeout>10</timeout>
          <options>
            <option>one</option>
            <option>two</option>
            <option>three</option>
          </options>
        </configuration>
      </plugin>
    </plugins>
  </build>
  ...
</project>

+----+

 As you can see the elements in the configuration match the names of the fields in the Mojo. The configuration
 mechanism Maven employs is very similar to the way {{{http://xstream.codehaus.org}XStream}} works where elements
 in XML are mapped to objects. So from the example above you can see that the mapping is pretty straight forward the
 <<<url>>> element maps to the <<<url>>> field, the <<<timeout>>> element maps to the <<<timeout>>> field and the
 <<<options>>> element maps to the <<<options>>> field. The mapping mechanism can deal with arrays by inspecting
 the type of the field and determining if a suitable mapping is possible.

  For mojos that are intended to be executed directly from the CLI, their parameters usually provide a means to be
  configured via system properties instead of a <<<\<configuration\>>>> section in the POM. The plugin documentation
  for those parameters will list an <expression> that denotes the system properties for the configuration. In the
  mojo above, the parameter <<<url>>> is associated with the expression <<<$\{query.url\}>>>, meaning its value can
  be specified by the system property <<<query.url>>> as shown below:

+----+
mvn myquery:query -Dquery.url=http://maven.apache.org
+----+

  Note that the name of the system property does not necessarily match the name of the mojo parameter. While this is
  a rather common practice, you will often notice plugins that employ some prefix for the system properties to avoid
  name clashes with other system properties. Though rarely, there are also plugin parameters that (e.g. for historical
  reasons) employ system properties which are completely unrelated to the parameter name. So be sure to have a close
  look at the plugin documentation.

* {Mapping Complex Objects}

  Mapping complex types is also fairly straight forward in Maven so let's look at a simple example where we
  are trying to map a configuration for Person object. The <<<\<configuration\>>>> element might look like the
  following:

+----+

...
<configuration>
 <person>
   <firstName>Jason</firstName>
   <lastName>van Zyl</lastName>
 </person>
</configuration>
...

+----+

 The rules for mapping complex objects are as follows:

 * There must be a private field that corresponds to name of the element being mapped. So in our case the
   <<<person>>> element must map to a <<<person>>> field in the mojo.

 * The object instantiated must be in the same package as the Mojo itself. So if your mojo is in
   <<<com.mycompany.mojo.query>>> then the mapping mechanism will look in that package for an
   object named <<<Person>>>. As you can see the mechanism will capitalize the first letter of
   the element name and use that to search for the object to instantiate.

 * If you wish to have the object to be instantiated live in a different package or have a more
   complicated name then you must specify this using an <<<implementation>>> attribute like the
   following:

 []

+----+

...
<configuration>
 <person implementation="com.mycompany.mojo.query.SuperPerson">
   <firstName>Jason</firstName>
   <lastName>van Zyl</lastName>
 </person>
</configuration>
...

+----+

* {Mapping Collections}

 The configuration mapping mechanism can easily deal with most collections so let's go through a few examples
 to show you how it's done:

** {Mapping Lists}

 Mapping lists works in much the same way as mapping to arrays where you a list of elements will be
 mapped to the List. So if you have a mojo like the following:

+----+

public class MyAnimalMojo
    extends AbstractMojo
{
    /**
     * @parameter
     */
    private List animals;

    public void execute()
        throws MojoExecutionException
    {
        ...
    }
}

+----+

 Where you have a field named <<<animals>>> then your configuration for the plug-in would look like the following:

+----+

<project>
  ...
  <build>
    <plugins>
      <plugin>
        <artifactId>maven-myanimal-plugin</artifactId>
        <version>1.0</version>
        <configuration>
          <animals>
            <animal>cat</animal>
            <animal>dog</animal>
            <animal>aardvark</animal>
          </animals>
        </configuration>
      </plugin>
    </plugins>
  </build>
  ...
</project>

+----+

 Where each of the animals listed would be entries in the <<<animals>>> field. Unlike arrays, collections have no
 specific component type. In order to derive the type of a list item, the following strategy is used:
 
  [[1]] If the XML element contains an <<<implementation>>> hint attribute, that is used

  [[2]] If the XML tag contains a <<<.>>>, try that as a fully qualified class name

  [[3]] Try the XML tag (with capitalized first letter) as a class in the same package as the mojo/object being
        configured

  [[4]] If the element has no children, assume its type is <<<String>>>. Otherwise, the configuration will fail.

  []

** {Mapping Maps}

 In the same way, you could define maps like the following:

+-----+
...
    /**
     * My Map.
     *
     * @parameter
     */
    private Map myMap;
...
+-----+

+-----+
...
  <configuration>
    <myMap>
      <key1>value1</key1>
      <key2>value2</key2>
    </myMap>
  </configuration>
...
+-----+

** {Mapping Properties}

 Properties should be defined like the following:

+-----+
...
    /**
     * My Properties.
     *
     * @parameter
     */
    private Properties myProperties;
...
+-----+

+-----+
...
  <configuration>
    <myProperties>
      <property>
        <name>propertyName1</name>
        <value>propertyValue1</value>
      <property>
      <property>
        <name>propertyName2</name>
        <value>propertyValue2</value>
      <property>
    </myProperties>
  </configuration>
...
+-----+

* {Using Setters}

 You are not restricted to using private field mapping which is good if you are trying to make you Mojos resuable
 outside the context of Maven. Using the example above we could name our private fields using the underscore
 convention and provide setters that the configuration mapping mechanism can use. So our Mojo would look
 like the following:

+----+

public class MyQueryMojo
    extends AbstractMojo
{
    /**
     * @parameter property="url"
     */
    private String _url;

    /**
     * @parameter property="timeout"
     */
    private int _timeout;

    /**
     * @parameter property="options"
     */
    private String[] _options;

    public void setUrl( String url )
    {
        _url = url;
    }

    public void setTimeout( int timeout )
    {
        _timeout = timeout;
    }

    public void setOptions( String[] options )
    {
        _options = options;
    }

    public void execute()
        throws MojoExecutionException
    {
        ...
    }
}

+----+

 Note the specification of the property name for each parameter which tells Maven what setter and getter to use when
 the field's name does not match the intended name of the parameter in the plugin configuration.

* {Using the <<<\<executions\>>>> Tag}

  You can also configure a mojo using the <<<\<executions\>>>> tag. This is most commonly used for mojos that are
  intended to participate in some phase of the build lifecycle. Using <<<MyQueryMojo>>> as an example, you may have
  something that will look like:

+----+
<project>
  ...
  <build>
    <plugins>
      <plugin>
        <artifactId>maven-myquery-plugin</artifactId>
        <version>1.0</version>
        <executions>
          <execution>
            <id>execution1</id>
            <phase>test</phase>
            <configuration>
              <url>http://www.foo.com/query</url>
              <timeout>10</timeout>
              <options>
                <option>one</option>
                <option>two</option>
                <option>three</option>
              </options>
            </configuration>
            <goals>
              <goal>query</goal>
            </goals>
          </execution>
          <execution>
            <id>execution2</id>
            <configuration>
              <url>http://www.bar.com/query</url>
              <timeout>15</timeout>
              <options>
                <option>four</option>
                <option>five</option>
                <option>six</option>
              </options>
            </configuration>
            <goals>
              <goal>query</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
  ...
</project>
+----+

  The first execution with id "execution1" binds this configuration to the test phase. The second execution does not
  have a <<<\<phase\>>>> tag, how do you think will this execution behave? Well, goals can have a default phase binding
  as discussed further below. If the goal has a default phase binding then it will execute in that phase. But if the
  goal is not bound to any lifecycle phase then it simply won't be executed during the build lifecycle.

  Note that while execution id's have to be unique among all executions of a single plugin within a POM, they don't
  have to be unique across an inheritance hierarchy of POMs.  Executions of the same id from different POMs are merged.
  The same applies to executions that are defined by profiles.

  How about if we have a multiple executions with different phases bound to it?
  How do you think will it behave? Let us use the example POM above again, but
  this time we shall bind <<<execution2>>> to a phase.

+----+
<project>
  ...
  <build>
    <plugins>
      <plugin>
        ...
        <executions>
          <execution>
            <id>execution1</id>
            <phase>test</phase>
            ...
          </execution>
          <execution>
            <id>execution2</id>
            <phase>install</phase>
            <configuration>
              <url>http://www.bar.com/query</url>
              <timeout>15</timeout>
              <options>
                <option>four</option>
                <option>five</option>
                <option>six</option>
              </options>
            </configuration>
            <goals>
              <goal>query</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
  ...
</project>
+----+

  If there are multiple executions bound to different phases, then the mojo is
  executed once for each phase indicated. Meaning, <<<execution1>>> will be
  executed applying the configuration setup when the phase of the build is test,
  and <<<execution2>>> will be executed applying the configuration setup when
  the build phase is already in install.

  Now, let us have another mojo example which shows a default lifecycle phase binding.

+----+
/**
 * @goal query
 * @phase package
 */
public class MyBindedQueryMojo
    extends AbstractMojo
{
    /**
     * @parameter expression="${query.url}"
     */
    private String url;

    /**
     * @parameter default-value="60"
     */
    private int timeout;

    /**
     * @parameter
     */
    private String[] options;

    public void execute()
        throws MojoExecutionException
    {
        ...
    }
}
+----+

  From the above mojo example, <<<MyBindedQueryMojo>>> is by default bound to the package phase
  (see the <<<@phase>>> notation). But if we want to execute this mojo during the install
  phase and not with package we can rebind this mojo into a new lifecycle phase
  using the <<<\<phase\>>>> tag under <<<\<execution\>>>>.

+----+
<project>
  ...
  <build>
    <plugins>
      <plugin>
        <artifactId>maven-myquery-plugin</artifactId>
        <version>1.0</version>
        <executions>
          <execution>
            <id>execution1</id>
            <phase>install</phase>
            <configuration>
              <url>http://www.bar.com/query</url>
              <timeout>15</timeout>
              <options>
                <option>four</option>
                <option>five</option>
                <option>six</option>
              </options>
            </configuration>
            <goals>
              <goal>query</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>
  ...
</project>
+----+

  Now, <<<MyBindedQueryMojo>>> default phase which is package has been overrided by
  install phase.

  <<Note:>> Configurations inside the <<<\<executions\>>>> tag differ from those that are outside
  <<<\<executions\>>>> in that they cannot be used from a direct command line
  invocation. Instead they are only applied when the lifecycle phase they are
  bound to are invoked.  Alternatively, if you move a configuration section
  outside of the executions section, it will apply globally to all invocations
  of the plugin.

